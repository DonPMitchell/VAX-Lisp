(progn
(setq allregs '(r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 ap fp sp pc))
(setq regcycle '(r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10))
(setq reglist (copy regcycle))
(setq dummy (setq lastins (list nil nil nil)))
(setq void '(* * * * * * * * * * * *))
(setq NIL '($ 0 1))
(setq $r0 '($ 0 r0))
(setq $r10 '($ 0 r10))
(setq $r11 '($ 0 r11))
(setq $t '($ 0 t))
(setq $ap '($ 0 ap))
(setq $fp '($ 0 fp))
(setq @sp '(@ 0 sp))
(setq r11+ '(@ + r11))
(setq ap+ '(@ + ap))
(setq fp+ '(@ + fp))
(setq sp+ '(@ + sp))
(setq sp- '(@ - sp))
(setq *fp+ '(* + fp))
(nconc regcycle regcycle)
(setq fns
(define '(
(compile (lambda (e bl firstlevel) (cond
	((atom e) (cond
		((null e) NIL)
		((setq x (memq e bl)) (cadr x))
		((numberp e) (cond
			((setq x (member e gcons)) (cadr x))
			(t (cadr (setq gcons (cons e (cons (gencon) gcons))))) ))
		((setq x (memq e gvars)) (cadr x))
		(t (cadr (setq gvars (cons e (cons (genglb) gvars))))) ))
	((eq (car e) 'lambda)
		(complambda e firstlevel (genlab) (genlab)) )
	((eq (car e) 'quote) (cond
		((setq x (memq (cadr e) gcons)) (cadr x))
		(t (cadr (setq gcons (cons (cadr e) (cons (gencon) gcons))))) ))
	((eq (car e) 'cdr)
		(indirect (compile (cadr e) bl nil)) )
	((eq (car e) 'car)
		(past (indirect (compile (cadr e) bl nil)) 4) )
	((eq (car e) 'cadr )
		(past (indirect (indirect (compile (cadr e) bl nil))) 4) )
	((eq (car e) 'caddr )
		(past (indirect (indirect (indirect (compile (cadr e) bl nil)))) 4) )
	((eq (car e) 'getpl)
		(past (indirect (compile (cadr e) bl nil)) 8) )
	((eq (car e) 'atom)
		(comptest (past (indirect (compile (cadr e) bl nil)) 4)
			  jumpgeq (genlab) (mnil (allocreg))) )
	((memq (car e) '(null not))
		(comptest (compile (cadr e) bl nil)
			  jumpnnil (genlab) (mnil (allocreg))) )
	((eq (car e) 'cond) (compcond (cdr e) (genlab) (genlab)
				(cond (firstlevel $r0) (t (allocreg))) bl firstlevel))
	((eq (car e) 'eq) (compcompare (reserve (compile (cadr e) bl nil))
		(compile (caddr e) bl nil) jumpneq (genlab)
		(mnil (allocreg))) )
	((eq (car e) 'cons) (construct (reserve (compile (cadr e) bl nil))
		(compile (caddr e) bl nil) (allocreg) ))
	((eq (car e) 'list) (complist (cdr e) bl nil))
	((eq (car e) 'progn) (comprogn (cdr e) bl firstlevel))
	(t (compfunction e bl firstlevel (genlab))) )))
(comptest (lambda (e j label reg) (progn
	(test e j label)
	(move (cond
			((setq x (memq 't gcons)) (cadr x))
			(t (cadr (setq gcons (cons 't (cons (gencon) gcons))))) )
		reg)
	(putlab label)
	reg )))
(compcompare (lambda (e1 e2 j label reg) (progn
	(compare e1 e2 j label)
	(move (cond
			((setq x (memq 't gcons)) (cadr x))
			(t (cadr (setq gcons (cons 't (cons (gencon) gcons))))) )
		reg)
	(putlab label)
	reg )))
(compcond (lambda (l endlab nextlab reg bl firstlevel) (cond
	((null l) (putlab endlab) (mnil reg))
	((or (eq 't (caar l)) (numberp (caar l)) (and
			(not (atom (caar l))) (eq (caaar l) 'quote) (cadaar l)))
		(move (comprogn (cond ((cdar l)) ((list (caar l)))) bl firstlevel) reg)
		(cond (firstlevel (ret reg)))
		(putlab endlab) reg )
	((cdar l)
		(compredicate (caar l) nextlab nil bl nil)
		(move (comprogn (cdar l) bl firstlevel) reg)
		(cond (firstlevel (ret reg)) ((cdr l) (jump endlab)))
		(putlab nextlab)
		(compcond (cdr l) endlab (genlab) reg bl firstlevel) )
	((cdr l)
		(test (move (compile (caar l) bl firstlevel) reg) jumpnnil endlab)
		(compcond (cdr l) endlab nextlab reg bl firstlevel) )
	(t	(move (compile (caar l) bl firstlevel) reg)
		(putlab endlab) reg ) )))
(compredicate (lambda (e nextlab invert bl firstlevel) (cond
	((eq e t) nil)
	((atom e) (test (compile e bl firstlevel)
			(cond (invert jumpnnil) (t jumpnil))
			nextlab) )
	((memq (car e) '(null not))
		(compredicate (cadr e) nextlab (not invert) bl firstlevel) )
	((eq (car e) 'atom)
		(test (past (indirect (compile (cadr e) bl firstlevel)) 4)
			(cond (invert jumplss) (t jumpgeq)) nextlab) )
	((eq (car e) 'eq)
		(compare (compile (cadr e) bl firstlevel)
			(compile (caddr e) bl firstlevel)
			(cond (invert jumpeql) (t jumpneq))
			nextlab) )
	((eq (car e) 'and) (mapc
		'(lambda (e) (compredicate e nextlab invert bl firstlevel))
		(cdr e) ))
	(t (test (compile e bl firstlevel)
		(cond (invert jumpnnil) (t jumpnil))
		nextlab) ) )))
(complist (lambda (l bl firstlevel) (cond
	((null l) NIL)
	(t
		(construct
			(reserve (compile (car l) bl firstlevel))
			(complist (cdr l) bl firstlevel) (allocreg) ) ) )))
(compfunction (lambda (form bl firstlevel retlab) (progn
	(cond (firstlevel (move $ap sp-))
		(t (code 'pushab nil (indirect retlab)) (code 'movq $ap sp-)) )
	(cond ((cdr form) (stack form bl firstlevel retlab))
		(t (move (compile (car form) bl firstlevel) $r0) (move $ap $fp)
			(jump '(@ + r0))
			(and (not firstlevel) (not (eq retlab calllab)) (putlab retlab))
			$r0 ) ) )))
(stack (lambda (l bl firstlevel retlab) (cond
	((null l) (cond
		(calllabdefd (jump calllab))
		(t (putlab calllab) (setq calllabdefd 't)
			(cond (firstlevel (move sp+ $fp)) ((move @sp $fp)))
			(code 'mcoml '($ 0 0) ap+)
			(move *fp+ $r10)
			(jump $r10) ) )
		(and (not firstlevel) (not (eq retlab calllab)) (putlab retlab))
		$r0 )
	((null (cdr l)) (cond
		((and (not (atom (car l))) (isclosedfunc (caar l)))
			(compfunction (car l) bl nil calllab)
			(and (not firstlevel) (not (eq retlab calllab)) (putlab retlab))
			$r0 )
		(t (move (compile (car l) bl firstlevel) $r0)
			(stack (cdr l) bl firstlevel retlab) ) ))
	((and (cddr l) (atom (car l)) (atom (cadr l)) (setq x (memq (car l) bl))
			(setq y (memq (cadr l) bl)) (eq y (cddr x)) )
		(code 'movq (cadr x) ap+)
		(stack (cddr l) bl firstlevel retlab) )
	(t (move (compile (car l) bl nil) ap+)
		(stack (cdr l) bl firstlevel retlab) ) )))
(isclosedfunc (lambda (fname) (not
	(memq fname '(cdr car cadr caddr atom quote null not cond eq cons list
		progn lambda getpl )) )))
(complambda (lambda (e firstlevel startlab skiplab) (progn
	(cond ((not firstlevel) (jump skiplab)))
	(putlab startlab)
	(setpl 'r0 'initial)
	(setq r0 $r0)
	(setq gvars nil) (setq gcons nil)
	(setq calllab (genlab)) (setq calllabdefd nil)
	(setq printss nil)
	(ret (move (compile (caddr e) (argframe (cadr e) 0) firstlevel) $r0))
	(cond ((not firstlevel) (putlab skiplab)))
	startlab )))
(argframe (lambda (bl off) (cond
	(bl (cond
		((null (cdr bl)) (cons (car bl) (cons $r0 nil)))
		((cons (car bl) (cons (list '@ off 'fp)
			(argframe (cdr bl) (plus off 4)) ))) )) )))
(comprogn (lambda (l bl firstlevel) (cond
	((null (cdr l)) (compile (car l) bl firstlevel))
	(t (compile (car l) bl nil) (comprogn (cdr l) bl firstlevel)) )))
(saveregs (lambda (rl off) (cond
	((null rl) off)
	((eq (getpl (car rl)) 'initial)
		(setpl (car rl) 'reserved)
		(move $r0 (list '@ (times 4 (sub1 (length bl))) 'ap))
		(saveregs (cdr rl) off) )
	((getpl (car rl))
		(move (eval (car rl)) (list '@ off 'ap))
		(replace (eval (car rl)) (list '@ off 'ap))
		(release (eval (car rl)))
		(set (cdr rl) nil)
		(saveregs (cdr rl) (plus 4 off)) )
	(t
		(set (car rl) nil)
		(saveregs (cdr rl) off) ) )))
(replace (lambda (l1 l2) (progn
	(print 'REPLACE)
	(print l1) (print l2)
	(rplaca l1 (car l2))
	(rplaca (cdr l1) (cadr l2))
	(rplaca (cddr l1) (caddr l2)) )))
(lc (lambda (fun) (progn
	(mapc '(lambda (e) (set e nil)) reglist)
	(mapc '(lambda (e) (setpl e nil)) reglist)
	(complambda (eval fun) t (list '$ 0 fun) (genlab)) )))
(ret (lambda (pass) (progn
	(code 'movq sp+ $ap)
	(code 'rsb nil nil) 
	pass)))
(allocreg (lambda () (cond
	((getpl (cadr regcycle))
		(setq regcycle (cdr regcycle))
		(allocreg) )
	(t (list '$ 0 (car (setq regcycle (cdr regcycle))))) )))
(release (lambda (op) (cond
	((memq (car op) reglist)
		(setpl (car op) nil)
		(set (car op) nil)
		op)
	(t op) )))
(reserve (lambda (op) (cond
	((memq (car op) reglist)
		(setpl (car op) 'reserved)
		(set (car op) op)
		op)
	(t op) )))
(regvalues (lambda () (mapcar eval reglist)))
(genlab (lambda () (list '$ 0 (gensym))))
(genglb (lambda () (list '* 0 (gensym))))
(gencon (lambda () (list '@ 0 (gensym))))
(putlab (lambda (label) (progn
	(princ (caddr label)) (princ colon) (terpri) (setq lastins dummy) )))
(move (lambda (src dst) (cond
	((equal src dst) dst)
	((zeroop src) (clear dst))
	((and (eq (car src) '$)
			(not (memq (caddr src) allregs))
			(not (numberp (caddr src))) )
		(code 'movab (indirect src) dst)
		dst)
	(t
		(code 'movl src dst)
		dst) )))
(clear (lambda (dst) (progn (code 'clrl nil dst) dst)))
(mnil (lambda (dst) (progn (code 'movl NIL dst) dst)))
(pushap (lambda (n firstlevel) (cond
	((zerop n) nil)
	(t (code 'addl2 (cons n $0) $ap)) )))
(test (lambda (op j lab) (cond
	((or (equal j jumpnil) (equal j jumpnnil)) (j op lab))
	((equal op (caddr lastins)) (j lab))
	((and (eq 'movl (car lastins)) (equal op (cadr lastins))) (j lab))
	((zeroop op) (cond
		((eq j jumpeql) (jump lab))
		((eq j jumpneq) nil)
		(t (code 'tstl nil op) (j lab)) ))
	(t (code 'tstl nil op)
		(j lab) ) )))
(compare (lambda (op1 op2 j lab) (cond
	((equal (release op1) op2) (cond
		((eq j jumpeql) (jump lab))
		((eq j jumpneq) nil)
		(t (code 'cmpl op1 op2) (j lab)) ))
	(t (code 'cmpl op1 op2)
		(j lab) ) )))
(construct (lambda (a d reg) (progn
	(move $r11 reg)
	(move d r11+)
	(move (release a) r11+)
	reg)))
(jumpeql (lambda (dst) (code 'jeql nil (indirect dst))))
(jumpneq (lambda (dst) (code 'jneq nil (indirect dst))))
(jumplss (lambda (dst) (code 'jlss nil (indirect dst))))
(jumpgeq (lambda (dst) (code 'jgeq nil (indirect dst))))
(jumpnil (lambda (op dst) (code 'jnil op (indirect dst))))
(jumpnnil (lambda (op dst) (code 'jnnil op (indirect dst))))
(indirect (lambda (op) (cond
	((eq (car op) '$) (cons '@ (cdr op)))
	((eq (car op) '@) (cons '* (cdr op)))
	(t (indirect (move op (allocreg)))) )))
(past (lambda (op n) (cond
	((eq (car op) '@) (cons '@ (cons (plus n (cadr op)) (cddr op))))
	(t (past (indirect (move (cons '@ (cdr op)) (allocreg))) n)) )))
(jump (lambda (dst) (cond
	((and (not (memq (caddr dst) allregs)) (eq (car dst) dollar))
		(code 'jbr nil (indirect dst)) )
	(t (code 'jmp nil (indirect dst))) )))
(zeroop (lambda (op) (and (numberp (car op)) (zerop (car op)))))
(registerp (lambda (reg) (and (memq (car reg) allregs) (eq (cadr reg) dollar))))
(code (lambda (op src1 dst) (cond
	((eq (car lastins) 'jmp) nil)
	((eq (car lastins) 'jbr) nil)
	(t
		(princ tab) (princ op)
		(cond (dst (princ tab)))
		(cond (src1 (printoperand src1) (princ comma)))
		(cond (dst (printoperand dst)))
		(setq lastins (list op src1 dst))
		(terpri) ) )))
(printoperand (lambda (op) (cond
	((eq (car op) '*)
		(princ '*)
		(printoperand (cons '@ (cdr op))) )
	((memq (caddr op) allregs) (cond
		((eq (car op) '$) (princ (caddr op)))
		(t (cond
			((eq (cadr op) '+)
				(princ (cddr op))
				(princ '+) )
			((eq (cadr op) '-)
				(princ '-)
				(princ (cddr op)) )
			((zerop (cadr op)) (princ (cddr op)))
			(t (princ (cadr op)) (princ (cddr op))) )) ))
	(t
		(cond ((not (eq (car op) '@)) (princ (car op))))
		(princ (caddr op))
		(cond
			((zerop (cadr op)) nil)
			(t (princ '+) (princ (cadr op))) ) ) )))
)))
(implode (list '# blank 'lisp blank 'compiler blank 'v4))
)
